import{t as Q,W as X,_ as tt,M as j,L as R}from"./index-e51db460.js";var et=function a(t,e){if(t===e)return!0;if(t&&e&&typeof t=="object"&&typeof e=="object"){if(t.constructor!==e.constructor)return!1;var s,n,i;if(Array.isArray(t)){if(s=t.length,s!=e.length)return!1;for(n=s;n--!==0;)if(!a(t[n],e[n]))return!1;return!0}if(t.constructor===RegExp)return t.source===e.source&&t.flags===e.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===e.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===e.toString();if(i=Object.keys(t),s=i.length,s!==Object.keys(e).length)return!1;for(n=s;n--!==0;)if(!Object.prototype.hasOwnProperty.call(e,i[n]))return!1;for(n=s;n--!==0;){var o=i[n];if(!a(t[o],e[o]))return!1}return!0}return t!==t&&e!==e};const $=Q(et),z=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],T=1,b=8;class F{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[e,s]=new Uint8Array(t,0,2);if(e!==219)throw new Error("Data does not appear to be in a KDBush format.");const n=s>>4;if(n!==T)throw new Error("Got v".concat(n," data when expected v").concat(T,"."));const i=z[s&15];if(!i)throw new Error("Unrecognized array type.");const[o]=new Uint16Array(t,2,1),[l]=new Uint32Array(t,4,1);return new F(l,o,i,t)}constructor(t,e=64,s=Float64Array,n){if(isNaN(t)||t<0)throw new Error("Unpexpected numItems value: ".concat(t,"."));this.numItems=+t,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=s,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const i=z.indexOf(this.ArrayType),o=t*2*this.ArrayType.BYTES_PER_ELEMENT,l=t*this.IndexArrayType.BYTES_PER_ELEMENT,r=(8-l%8)%8;if(i<0)throw new Error("Unexpected typed array class: ".concat(s,"."));n&&n instanceof ArrayBuffer?(this.data=n,this.ids=new this.IndexArrayType(this.data,b,t),this.coords=new this.ArrayType(this.data,b+l+r,t*2),this._pos=t*2,this._finished=!0):(this.data=new ArrayBuffer(b+o+l+r),this.ids=new this.IndexArrayType(this.data,b,t),this.coords=new this.ArrayType(this.data,b+l+r,t*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,(T<<4)+i]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=t)}add(t,e){const s=this._pos>>1;return this.ids[s]=s,this.coords[this._pos++]=t,this.coords[this._pos++]=e,s}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error("Added ".concat(t," items when expected ").concat(this.numItems,"."));return B(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,s,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:o,nodeSize:l}=this,r=[0,i.length-1,0],d=[];for(;r.length;){const h=r.pop()||0,c=r.pop()||0,p=r.pop()||0;if(c-p<=l){for(let m=p;m<=c;m++){const y=o[2*m],M=o[2*m+1];y>=t&&y<=s&&M>=e&&M<=n&&d.push(i[m])}continue}const u=p+c>>1,g=o[2*u],f=o[2*u+1];g>=t&&g<=s&&f>=e&&f<=n&&d.push(i[u]),(h===0?t<=g:e<=f)&&(r.push(p),r.push(u-1),r.push(1-h)),(h===0?s>=g:n>=f)&&(r.push(u+1),r.push(c),r.push(1-h))}return d}within(t,e,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:n,coords:i,nodeSize:o}=this,l=[0,n.length-1,0],r=[],d=s*s;for(;l.length;){const h=l.pop()||0,c=l.pop()||0,p=l.pop()||0;if(c-p<=o){for(let m=p;m<=c;m++)G(i[2*m],i[2*m+1],t,e)<=d&&r.push(n[m]);continue}const u=p+c>>1,g=i[2*u],f=i[2*u+1];G(g,f,t,e)<=d&&r.push(n[u]),(h===0?t-s<=g:e-s<=f)&&(l.push(p),l.push(u-1),l.push(1-h)),(h===0?t+s>=g:e+s>=f)&&(l.push(u+1),l.push(c),l.push(1-h))}return r}}function B(a,t,e,s,n,i){if(n-s<=e)return;const o=s+n>>1;V(a,t,o,s,n,i),B(a,t,e,s,o-1,1-i),B(a,t,e,o+1,n,1-i)}function V(a,t,e,s,n,i){for(;n>s;){if(n-s>600){const d=n-s+1,h=e-s+1,c=Math.log(d),p=.5*Math.exp(2*c/3),u=.5*Math.sqrt(c*p*(d-p)/d)*(h-d/2<0?-1:1),g=Math.max(s,Math.floor(e-h*p/d+u)),f=Math.min(n,Math.floor(e+(d-h)*p/d+u));V(a,t,e,g,f,i)}const o=t[2*e+i];let l=s,r=n;for(I(a,t,s,e),t[2*n+i]>o&&I(a,t,s,n);l<r;){for(I(a,t,l,r),l++,r--;t[2*l+i]<o;)l++;for(;t[2*r+i]>o;)r--}t[2*s+i]===o?I(a,t,s,r):(r++,I(a,t,r,n)),r<=e&&(s=r+1),e<=r&&(n=r-1)}}function I(a,t,e,s){S(a,e,s),S(t,2*e,2*s),S(t,2*e+1,2*s+1)}function S(a,t,e){const s=a[t];a[t]=a[e],a[e]=s}function G(a,t,e,s){const n=a-e,i=t-s;return n*n+i*i}const st={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:a=>a},H=Math.fround||(a=>t=>(a[0]=+t,a[0]))(new Float32Array(1)),E=2,v=3,_=4,L=5,K=6;class nt{constructor(t){this.options=Object.assign(Object.create(st),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:e,minZoom:s,maxZoom:n}=this.options;e&&console.time("total time");const i="prepare ".concat(t.length," points");e&&console.time(i),this.points=t;const o=[];for(let r=0;r<t.length;r++){const d=t[r];if(!d.geometry)continue;const[h,c]=d.geometry.coordinates,p=H(P(h)),u=H(x(c));o.push(p,u,1/0,r,-1,1),this.options.reduce&&o.push(0)}let l=this.trees[n+1]=this._createTree(o);e&&console.timeEnd(i);for(let r=n;r>=s;r--){const d=+Date.now();l=this.trees[r]=this._createTree(this._cluster(l,r)),e&&console.log("z%d: %d clusters in %dms",r,l.numItems,+Date.now()-d)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let s=((t[0]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,t[1]));let i=t[2]===180?180:((t[2]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)s=-180,i=180;else if(s>i){const c=this.getClusters([s,n,180,o],e),p=this.getClusters([-180,n,i,o],e);return c.concat(p)}const l=this.trees[this._limitZoom(e)],r=l.range(P(s),x(o),P(i),x(n)),d=l.data,h=[];for(const c of r){const p=this.stride*c;h.push(d[p+L]>1?W(d,p,this.clusterProps):this.points[d[p+v]])}return h}getChildren(t){const e=this._getOriginId(t),s=this._getOriginZoom(t),n="No cluster with the specified id.",i=this.trees[s];if(!i)throw new Error(n);const o=i.data;if(e*this.stride>=o.length)throw new Error(n);const l=this.options.radius/(this.options.extent*Math.pow(2,s-1)),r=o[e*this.stride],d=o[e*this.stride+1],h=i.within(r,d,l),c=[];for(const p of h){const u=p*this.stride;o[u+_]===t&&c.push(o[u+L]>1?W(o,u,this.clusterProps):this.points[o[u+v]])}if(c.length===0)throw new Error(n);return c}getLeaves(t,e,s){e=e||10,s=s||0;const n=[];return this._appendLeaves(n,t,e,s,0),n}getTile(t,e,s){const n=this.trees[this._limitZoom(t)],i=Math.pow(2,t),{extent:o,radius:l}=this.options,r=l/o,d=(s-r)/i,h=(s+1+r)/i,c={features:[]};return this._addTileFeatures(n.range((e-r)/i,d,(e+1+r)/i,h),n.data,e,s,i,c),e===0&&this._addTileFeatures(n.range(1-r/i,d,1,h),n.data,i,s,i,c),e===i-1&&this._addTileFeatures(n.range(0,d,r/i,h),n.data,-1,s,i,c),c.features.length?c:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const s=this.getChildren(t);if(e++,s.length!==1)break;t=s[0].properties.cluster_id}return e}_appendLeaves(t,e,s,n,i){const o=this.getChildren(e);for(const l of o){const r=l.properties;if(r&&r.cluster?i+r.point_count<=n?i+=r.point_count:i=this._appendLeaves(t,r.cluster_id,s,n,i):i<n?i++:t.push(l),t.length===s)break}return i}_createTree(t){const e=new F(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let s=0;s<t.length;s+=this.stride)e.add(t[s],t[s+1]);return e.finish(),e.data=t,e}_addTileFeatures(t,e,s,n,i,o){for(const l of t){const r=l*this.stride,d=e[r+L]>1;let h,c,p;if(d)h=J(e,r,this.clusterProps),c=e[r],p=e[r+1];else{const f=this.points[e[r+v]];h=f.properties;const[m,y]=f.geometry.coordinates;c=P(m),p=x(y)}const u={type:1,geometry:[[Math.round(this.options.extent*(c*i-s)),Math.round(this.options.extent*(p*i-n))]],tags:h};let g;d||this.options.generateId?g=e[r+v]:g=this.points[e[r+v]].id,g!==void 0&&(u.id=g),o.features.push(u)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const{radius:s,extent:n,reduce:i,minPoints:o}=this.options,l=s/(n*Math.pow(2,e)),r=t.data,d=[],h=this.stride;for(let c=0;c<r.length;c+=h){if(r[c+E]<=e)continue;r[c+E]=e;const p=r[c],u=r[c+1],g=t.within(r[c],r[c+1],l),f=r[c+L];let m=f;for(const y of g){const M=y*h;r[M+E]>e&&(m+=r[M+L])}if(m>f&&m>=o){let y=p*f,M=u*f,k,U=-1;const O=((c/h|0)<<5)+(e+1)+this.points.length;for(const q of g){const C=q*h;if(r[C+E]<=e)continue;r[C+E]=e;const N=r[C+L];y+=r[C]*N,M+=r[C+1]*N,r[C+_]=O,i&&(k||(k=this._map(r,c,!0),U=this.clusterProps.length,this.clusterProps.push(k)),i(k,this._map(r,C)))}r[c+_]=O,d.push(y/m,M/m,1/0,O,-1,m),i&&d.push(U)}else{for(let y=0;y<h;y++)d.push(r[c+y]);if(m>1)for(const y of g){const M=y*h;if(!(r[M+E]<=e)){r[M+E]=e;for(let k=0;k<h;k++)d.push(r[M+k])}}}}return d}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,s){if(t[e+L]>1){const o=this.clusterProps[t[e+K]];return s?Object.assign({},o):o}const n=this.points[t[e+v]].properties,i=this.options.map(n);return s&&i===n?Object.assign({},i):i}}function W(a,t,e){return{type:"Feature",id:a[t+v],properties:J(a,t,e),geometry:{type:"Point",coordinates:[it(a[t]),ot(a[t+1])]}}}function J(a,t,e){const s=a[t+L],n=s>=1e4?"".concat(Math.round(s/1e3),"k"):s>=1e3?"".concat(Math.round(s/100)/10,"k"):s,i=a[t+K],o=i===-1?{}:Object.assign({},e[i]);return Object.assign(o,{cluster:!0,cluster_id:a[t+v],point_count:s,point_count_abbreviated:n})}function P(a){return a/360+.5}function x(a){const t=Math.sin(a*Math.PI/180),e=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return e<0?0:e>1?1:e}function it(a){return(a-.5)*360}function ot(a){const t=(180-a*360)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function rt(a,t){var e={};for(var s in a)Object.prototype.hasOwnProperty.call(a,s)&&t.indexOf(s)<0&&(e[s]=a[s]);if(a!=null&&typeof Object.getOwnPropertySymbols=="function")for(var n=0,s=Object.getOwnPropertySymbols(a);n<s.length;n++)t.indexOf(s[n])<0&&Object.prototype.propertyIsEnumerable.call(a,s[n])&&(e[s[n]]=a[s[n]]);return e}class w{static isAdvancedMarkerAvailable(t){return google.maps.marker&&t.getMapCapabilities().isAdvancedMarkersAvailable===!0}static isAdvancedMarker(t){return google.maps.marker&&t instanceof google.maps.marker.AdvancedMarkerElement}static setMap(t,e){this.isAdvancedMarker(t)?t.map=e:t.setMap(e)}static getPosition(t){if(this.isAdvancedMarker(t)){if(t.position){if(t.position instanceof google.maps.LatLng)return t.position;if(t.position.lat&&t.position.lng)return new google.maps.LatLng(t.position.lat,t.position.lng)}return new google.maps.LatLng(null)}return t.getPosition()}static getVisible(t){return this.isAdvancedMarker(t)?!0:t.getVisible()}}class Z{constructor({markers:t,position:e}){this.markers=t,e&&(e instanceof google.maps.LatLng?this._position=e:this._position=new google.maps.LatLng(e))}get bounds(){if(this.markers.length===0&&!this._position)return;const t=new google.maps.LatLngBounds(this._position,this._position);for(const e of this.markers)t.extend(w.getPosition(e));return t}get position(){return this._position||this.bounds.getCenter()}get count(){return this.markers.filter(t=>w.getVisible(t)).length}push(t){this.markers.push(t)}delete(){this.marker&&(w.setMap(this.marker,null),this.marker=void 0),this.markers.length=0}}class at{constructor({maxZoom:t=16}){this.maxZoom=t}noop({markers:t}){return lt(t)}}const lt=a=>a.map(e=>new Z({position:w.getPosition(e),markers:[e]}));class Y extends at{constructor(t){var{maxZoom:e,radius:s=60}=t,n=rt(t,["maxZoom","radius"]);super({maxZoom:e}),this.state={zoom:-1},this.superCluster=new nt(Object.assign({maxZoom:this.maxZoom,radius:s},n))}calculate(t){let e=!1;const s={zoom:t.map.getZoom()};if(!$(t.markers,this.markers)){e=!0,this.markers=[...t.markers];const n=this.markers.map(i=>{const o=w.getPosition(i);return{type:"Feature",geometry:{type:"Point",coordinates:[o.lng(),o.lat()]},properties:{marker:i}}});this.superCluster.load(n)}return e||(this.state.zoom<=this.maxZoom||s.zoom<=this.maxZoom)&&(e=!$(this.state,s)),this.state=s,e&&(this.clusters=this.cluster(t)),{clusters:this.clusters,changed:e}}cluster({map:t}){return this.superCluster.getClusters([-180,-90,180,90],Math.round(t.getZoom())).map(e=>this.transformCluster(e))}transformCluster({geometry:{coordinates:[t,e]},properties:s}){if(s.cluster)return new Z({markers:this.superCluster.getLeaves(s.cluster_id,1/0).map(i=>i.properties.marker),position:{lat:e,lng:t}});const n=s.marker;return new Z({markers:[n],position:w.getPosition(n)})}}class ct{constructor(t,e){this.markers={sum:t.length};const s=e.map(i=>i.count),n=s.reduce((i,o)=>i+o,0);this.clusters={count:e.length,markers:{mean:n/e.length,sum:n,min:Math.min(...s),max:Math.max(...s)}}}}class dt{render({count:t,position:e},s,n){const i=t>Math.max(10,s.clusters.markers.mean)?"#ff0000":"#0000ff",o='<svg fill="'.concat(i,'" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">\n<circle cx="120" cy="120" opacity=".6" r="70" />\n<circle cx="120" cy="120" opacity=".3" r="90" />\n<circle cx="120" cy="120" opacity=".2" r="110" />\n<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">').concat(t,"</text>\n</svg>"),l="Cluster of ".concat(t," markers"),r=Number(google.maps.Marker.MAX_ZINDEX)+t;if(w.isAdvancedMarkerAvailable(n)){const c=new DOMParser().parseFromString(o,"image/svg+xml").documentElement;c.setAttribute("transform","translate(0 25)");const p={map:n,position:e,zIndex:r,title:l,content:c};return new google.maps.marker.AdvancedMarkerElement(p)}const d={position:e,zIndex:r,title:l,icon:{url:"data:image/svg+xml;base64,".concat(btoa(o)),anchor:new google.maps.Point(25,25)}};return new google.maps.Marker(d)}}function ht(a,t){for(let e in t.prototype)a.prototype[e]=t.prototype[e]}class D{constructor(){ht(D,google.maps.OverlayView)}}var A;(function(a){a.CLUSTERING_BEGIN="clusteringbegin",a.CLUSTERING_END="clusteringend",a.CLUSTER_CLICK="click"})(A||(A={}));const pt=(a,t,e)=>{e.fitBounds(t.bounds)};class ut extends D{constructor({map:t,markers:e=[],algorithmOptions:s={},algorithm:n=new Y(s),renderer:i=new dt,onClusterClick:o=pt}){super(),this.markers=[...e],this.clusters=[],this.algorithm=n,this.renderer=i,this.onClusterClick=o,t&&this.setMap(t)}addMarker(t,e){this.markers.includes(t)||(this.markers.push(t),e||this.render())}addMarkers(t,e){t.forEach(s=>{this.addMarker(s,!0)}),e||this.render()}removeMarker(t,e){const s=this.markers.indexOf(t);return s===-1?!1:(w.setMap(t,null),this.markers.splice(s,1),e||this.render(),!0)}removeMarkers(t,e){let s=!1;return t.forEach(n=>{s=this.removeMarker(n,!0)||s}),s&&!e&&this.render(),s}clearMarkers(t){this.markers.length=0,t||this.render()}render(){const t=this.getMap();if(t instanceof google.maps.Map&&t.getProjection()){google.maps.event.trigger(this,A.CLUSTERING_BEGIN,this);const{clusters:e,changed:s}=this.algorithm.calculate({markers:this.markers,map:t,mapCanvasProjection:this.getProjection()});if(s||s==null){const n=new Set;for(const o of e)o.markers.length==1&&n.add(o.markers[0]);const i=[];for(const o of this.clusters)o.marker!=null&&(o.markers.length==1?n.has(o.marker)||w.setMap(o.marker,null):i.push(o.marker));this.clusters=e,this.renderClusters(),requestAnimationFrame(()=>i.forEach(o=>w.setMap(o,null)))}google.maps.event.trigger(this,A.CLUSTERING_END,this)}}onAdd(){this.idleListener=this.getMap().addListener("idle",this.render.bind(this)),this.render()}onRemove(){google.maps.event.removeListener(this.idleListener),this.reset()}reset(){this.markers.forEach(t=>w.setMap(t,null)),this.clusters.forEach(t=>t.delete()),this.clusters=[]}renderClusters(){const t=new ct(this.markers,this.clusters),e=this.getMap();this.clusters.forEach(s=>{s.markers.length===1?s.marker=s.markers[0]:(s.marker=this.renderer.render(s,t,e),s.markers.forEach(n=>w.setMap(n,null)),this.onClusterClick&&s.marker.addListener("click",n=>{google.maps.event.trigger(this,A.CLUSTER_CLICK,s),this.onClusterClick(n,s,e)})),w.setMap(s.marker,e)})}}class gt extends X{constructor(){super(...arguments),this.gMapsRef=void 0,this.AdvancedMarkerElement=void 0,this.PinElement=void 0,this.maps={},this.currMarkerId=0,this.currPolygonId=0,this.currCircleId=0,this.currPolylineId=0,this.currMapId=0,this.onClusterClickHandler=(t,e,s)=>{var n;const i=this.getIdFromMap(s),o=[];if(e.markers!=null&&this.AdvancedMarkerElement){for(const l of e.markers)if(l instanceof this.AdvancedMarkerElement){const r=this.getIdFromMarker(i,l),d=l.position;o.push({markerId:r,latitude:d.lat,longitude:d.lng,title:(n=l.title)!==null&&n!==void 0?n:"",snippet:""})}}this.notifyListeners("onClusterClick",{mapId:i,latitude:e.position.lat,longitude:e.position.lng,size:e.count,items:o})}}getIdFromMap(t){for(const e in this.maps)if(this.maps[e].map==t)return e;return""}getIdFromMarker(t,e){for(const s in this.maps[t].markers)if(this.maps[t].markers[s]==e)return s;return""}async importGoogleLib(t,e,s){if(this.gMapsRef===void 0){const n=await tt(()=>import("./index-6ed5e4d2.js"),[]),o=await new n.Loader({apiKey:t!=null?t:"",version:"weekly",libraries:["places"],language:s,region:e}).load();this.gMapsRef=o.maps;const{AdvancedMarkerElement:l,PinElement:r}=await o.maps.importLibrary("marker");this.AdvancedMarkerElement=l,this.PinElement=r,console.log("Loaded google maps API")}}async enableTouch(t){this.maps[t.id].map.setOptions({gestureHandling:"auto"})}async disableTouch(t){this.maps[t.id].map.setOptions({gestureHandling:"none"})}async setCamera(t){this.maps[t.id].map.moveCamera({center:t.config.coordinate,heading:t.config.bearing,tilt:t.config.angle,zoom:t.config.zoom})}async getMapType(t){let e=this.maps[t.id].map.getMapTypeId();if(e!==void 0)return e==="roadmap"&&(e=j.Normal),{type:"".concat(e.charAt(0).toUpperCase()).concat(e.slice(1))};throw new Error("Map type is undefined")}async setMapType(t){let e=t.mapType.toLowerCase();t.mapType===j.Normal&&(e="roadmap"),this.maps[t.id].map.setMapTypeId(e)}async enableIndoorMaps(){throw new Error("Method not supported on web.")}async enableTrafficLayer(t){var e;const s=(e=this.maps[t.id].trafficLayer)!==null&&e!==void 0?e:new google.maps.TrafficLayer;t.enabled?(s.setMap(this.maps[t.id].map),this.maps[t.id].trafficLayer=s):this.maps[t.id].trafficLayer&&(s.setMap(null),this.maps[t.id].trafficLayer=void 0)}async enableAccessibilityElements(){throw new Error("Method not supported on web.")}dispatchMapEvent(){throw new Error("Method not supported on web.")}async enableCurrentLocation(t){if(t.enabled)if(navigator.geolocation)navigator.geolocation.getCurrentPosition(e=>{const s={lat:e.coords.latitude,lng:e.coords.longitude};this.maps[t.id].map.setCenter(s),this.notifyListeners("onMyLocationButtonClick",{}),this.notifyListeners("onMyLocationClick",{})},()=>{throw new Error("Geolocation not supported on web browser.")});else throw new Error("Geolocation not supported on web browser.")}async setPadding(t){const e=this.maps[t.id].map.getBounds();e!==void 0&&this.maps[t.id].map.fitBounds(e,t.padding)}async getMapBounds(t){const e=this.maps[t.id].map.getBounds();if(!e)throw new Error("Google Map Bounds could not be found.");return new R({southwest:{lat:e.getSouthWest().lat(),lng:e.getSouthWest().lng()},center:{lat:e.getCenter().lat(),lng:e.getCenter().lng()},northeast:{lat:e.getNorthEast().lat(),lng:e.getNorthEast().lng()}})}async fitBounds(t){const e=this.maps[t.id].map,s=this.getLatLngBounds(t.bounds);e.fitBounds(s,t.padding)}async addMarkers(t){const e=[],s=this.maps[t.id];for(const n of t.markers){const i=this.buildMarkerOpts(n,s.map),o=""+this.currMarkerId;s.markers[o]=i,await this.setMarkerListeners(t.id,o,i),e.push(o),this.currMarkerId++}return{ids:e}}async addMarker(t){const e=this.buildMarkerOpts(t.marker,this.maps[t.id].map),s=""+this.currMarkerId;return this.maps[t.id].markers[s]=e,await this.setMarkerListeners(t.id,s,e),this.currMarkerId++,{id:s}}async removeMarkers(t){const e=this.maps[t.id];for(const s of t.markerIds)e.markers[s]&&(e.markers[s].map=null,delete e.markers[s])}async removeMarker(t){this.maps[t.id].markers[t.markerId]&&(this.maps[t.id].markers[t.markerId].map=null,delete this.maps[t.id].markers[t.markerId])}async addPolygons(t){const e=[],s=this.maps[t.id];for(const n of t.polygons){const i=new google.maps.Polygon(n);i.setMap(s.map);const o=""+this.currPolygonId;this.maps[t.id].polygons[o]=i,this.setPolygonListeners(t.id,o,i),e.push(o),this.currPolygonId++}return{ids:e}}async removePolygons(t){const e=this.maps[t.id];for(const s of t.polygonIds)e.polygons[s].setMap(null),delete e.polygons[s]}async addCircles(t){const e=[],s=this.maps[t.id];for(const n of t.circles){const i=new google.maps.Circle(n);i.setMap(s.map);const o=""+this.currCircleId;this.maps[t.id].circles[o]=i,this.setCircleListeners(t.id,o,i),e.push(o),this.currCircleId++}return{ids:e}}async removeCircles(t){const e=this.maps[t.id];for(const s of t.circleIds)e.circles[s].setMap(null),delete e.circles[s]}async addPolylines(t){const e=[],s=this.maps[t.id];for(const n of t.polylines){const i=new google.maps.Polyline(n);i.set("tag",n.tag),i.setMap(s.map);const o=""+this.currPolylineId;this.maps[t.id].polylines[o]=i,this.setPolylineListeners(t.id,o,i),e.push(o),this.currPolylineId++}return{ids:e}}async removePolylines(t){const e=this.maps[t.id];for(const s of t.polylineIds)e.polylines[s].setMap(null),delete e.polylines[s]}async enableClustering(t){var e;const s=[];for(const n in this.maps[t.id].markers)s.push(this.maps[t.id].markers[n]);this.maps[t.id].markerClusterer=new ut({map:this.maps[t.id].map,markers:s,algorithm:new Y({minPoints:(e=t.minClusterSize)!==null&&e!==void 0?e:4}),onClusterClick:this.onClusterClickHandler})}async disableClustering(t){const e=this.maps[t.id];if(e.markerClusterer){const s=Object.values(e.markers);e.markerClusterer.setMap(null),e.markerClusterer=void 0;for(const n of s)n.map=e.map}}async onScroll(){throw new Error("Method not supported on web.")}async onResize(){throw new Error("Method not supported on web.")}async onDisplay(){throw new Error("Method not supported on web.")}async create(t){console.log("Create map: ".concat(t.id)),await this.importGoogleLib(t.apiKey,t.region,t.language);const e=Object.assign({},t.config);e.mapId||(e.mapId="capacitor_map_".concat(this.currMapId++)),this.maps[t.id]={map:new window.google.maps.Map(t.element,e),element:t.element,markers:{},polygons:{},circles:{},polylines:{}},this.setMapListeners(t.id)}async destroy(t){console.log("Destroy map: ".concat(t.id));const e=this.maps[t.id];e.element.innerHTML="",e.map.unbindAll(),delete this.maps[t.id]}async mapBoundsContains(t){const e=this.getLatLngBounds(t.bounds),s=new google.maps.LatLng(t.point.lat,t.point.lng);return{contains:e.contains(s)}}async mapBoundsExtend(t){const e=this.getLatLngBounds(t.bounds),s=new google.maps.LatLng(t.point.lat,t.point.lng);return e.extend(s),{bounds:new R({southwest:{lat:e.getSouthWest().lat(),lng:e.getSouthWest().lng()},center:{lat:e.getCenter().lat(),lng:e.getCenter().lng()},northeast:{lat:e.getNorthEast().lat(),lng:e.getNorthEast().lng()}})}}getLatLngBounds(t){return new google.maps.LatLngBounds(new google.maps.LatLng(t.southwest.lat,t.southwest.lng),new google.maps.LatLng(t.northeast.lat,t.northeast.lng))}async setCircleListeners(t,e,s){s.addListener("click",()=>{this.notifyListeners("onCircleClick",{mapId:t,circleId:e,tag:s.get("tag")})})}async setPolygonListeners(t,e,s){s.addListener("click",()=>{this.notifyListeners("onPolygonClick",{mapId:t,polygonId:e,tag:s.get("tag")})})}async setPolylineListeners(t,e,s){s.addListener("click",()=>{this.notifyListeners("onPolylineClick",{mapId:t,polylineId:e,tag:s.get("tag")})})}async setMarkerListeners(t,e,s){s.addListener("click",()=>{var n;const i=s.position;this.notifyListeners("onMarkerClick",{mapId:t,markerId:e,latitude:i.lat,longitude:i.lng,title:(n=s.title)!==null&&n!==void 0?n:"",snippet:""})}),s.gmpDraggable&&(s.addListener("dragstart",()=>{var n;const i=s.position;this.notifyListeners("onMarkerDragStart",{mapId:t,markerId:e,latitude:i.lat,longitude:i.lng,title:(n=s.title)!==null&&n!==void 0?n:"",snippet:""})}),s.addListener("drag",()=>{var n;const i=s.position;this.notifyListeners("onMarkerDrag",{mapId:t,markerId:e,latitude:i.lat,longitude:i.lng,title:(n=s.title)!==null&&n!==void 0?n:"",snippet:""})}),s.addListener("dragend",()=>{var n;const i=s.position;this.notifyListeners("onMarkerDragEnd",{mapId:t,markerId:e,latitude:i.lat,longitude:i.lng,title:(n=s.title)!==null&&n!==void 0?n:"",snippet:""})}))}async setMapListeners(t){const e=this.maps[t].map;e.addListener("idle",async()=>{var s,n;const i=await this.getMapBounds({id:t});this.notifyListeners("onCameraIdle",{mapId:t,bearing:e.getHeading(),bounds:i,latitude:(s=e.getCenter())===null||s===void 0?void 0:s.lat(),longitude:(n=e.getCenter())===null||n===void 0?void 0:n.lng(),tilt:e.getTilt(),zoom:e.getZoom()})}),e.addListener("center_changed",()=>{this.notifyListeners("onCameraMoveStarted",{mapId:t,isGesture:!0})}),e.addListener("bounds_changed",async()=>{var s,n;const i=await this.getMapBounds({id:t});this.notifyListeners("onBoundsChanged",{mapId:t,bearing:e.getHeading(),bounds:i,latitude:(s=e.getCenter())===null||s===void 0?void 0:s.lat(),longitude:(n=e.getCenter())===null||n===void 0?void 0:n.lng(),tilt:e.getTilt(),zoom:e.getZoom()})}),e.addListener("click",s=>{var n,i;this.notifyListeners("onMapClick",{mapId:t,latitude:(n=s.latLng)===null||n===void 0?void 0:n.lat(),longitude:(i=s.latLng)===null||i===void 0?void 0:i.lng()})}),this.notifyListeners("onMapReady",{mapId:t})}buildMarkerOpts(t,e){var s;if(!this.AdvancedMarkerElement||!this.PinElement)throw new Error("Marker library not loaded");let n;if(t.iconUrl){const o=document.createElement("img");o.src=t.iconUrl,t.iconSize&&(o.style.width="".concat(t.iconSize.width,"px"),o.style.height="".concat(t.iconSize.height,"px")),n=o}else{const o={scale:(s=t.opacity)!==null&&s!==void 0?s:1,glyph:t.title,background:t.tintColor?"rgb(".concat(t.tintColor.r,", ").concat(t.tintColor.g,", ").concat(t.tintColor.b,")"):void 0};n=new this.PinElement(o).element}return new this.AdvancedMarkerElement({position:t.coordinate,map:e,content:n,title:t.title,gmpDraggable:t.draggable})}}export{gt as CapacitorGoogleMapsWeb};
